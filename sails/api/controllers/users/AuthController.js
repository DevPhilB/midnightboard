/**
 * AuthController
 *
 * @description :: Server-side logic for managing Authentication and Authorization
 * @help        :: See http://sailsjs.org/#!/documentation/concepts/Controllers
 */

const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

// Regex to check for correctness of passwords and email addresses
// Password must contain atleast: 8 characters, 1 uppcercase letter, 1 lowercase letter, 1 number and/or special character
let PASSWORD_REGEX = new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9]|.*[@$!%*?&])[A-Za-z0-9@$!%*?&]{8,}$');
// Email Address may not contain illegal special characters and must conform to naming conventions (eg.  user.name@domain.vw.xy)
let EMAIL_REGEX = new RegExp('^(?=[a-zA-Z0-9][a-zA-Z0-9@._%+-]{5,253}$)[a-zA-Z0-9._%+-]{1,64}@(?:(?=[a-zA-Z0-9-]{1,63}\.)[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*\.){1,8}[a-zA-Z]{2,63}$');

module.exports = {
  registerUser: async function(req, res) {
    if(!EMAIL_REGEX.test(req.param('email'))){
      return res.badRequest(new Error('Invalid e-mail address'));
    }
    if(!PASSWORD_REGEX.test(req.param('password'))){
      return res.badRequest(new Error('Password must be atleast 8 characters long and contain atleast 1 lowercase character, 1 uppercase character, and 1 number or special character'));
    }

    sails.log.verbose('AUTH_REGISTER::: Trying to create user ' + req.param('userName'));
    var hashedPassword = '';
    try {
      hashedPassword = await bcrypt.hash(req.param('password'), 10);
    }
    catch(err) {
      sails.log.debug('AUTH_REGISTER_ERR::: ' + err);
      return res.serverError();
    }

    await Member.create({
      userName: req.param('userName'),
      email: req.param('email'),
      password: hashedPassword,
      firstName: req.param('firstName'),
      lastName: req.param('lastName')
    });

    return res.ok();
  },

  loginUser: async function(req, res){
    var usr = await Member.findOne({userName: req.param('username')}); // Search for user by username
    if(!usr){ usr = await Member.findOne({email: req.param('username')}); } // Search for user by email
    if(!usr){ res.status(403).send('Incorrect username or password'); }
    try{
      sails.log.verbose('AUTH_LOGIN::: Trying to log in user ' + req.param('username'));
      if(await bcrypt.compare(req.param('password'), usr.password)){
        const tokenData = {name: usr.userName, id: usr.id}; // Date that is stored within each JWT

        const acessToken = jwt.sign(tokenData, sails.config.jwts.ACCESS_TOKEN_SECRET, { expiresIn: sails.config.jwts.EXPIRATION_TIME });
        const refreshToken = jwt.sign(tokenData, sails.config.jwts.REFRESH_TOKEN_SECRET);
        await RefreshToken.create({uid: usr.id, refreshToken: refreshToken}); // Save refresh token to database

        return res.json({accessToken: acessToken, refreshToken: refreshToken});
      } else {
        return res.status(403).send('Incorrect username or password');
      }
    }
    catch(err) {
      sails.log.debug('AUTH_LOGIN_ERR::: ' + err);
      return res.serverError();
    }
  },

  logoutUser: async function(req, res){
    var usr = null;
    // Logout user with existing refresh token
    if(req.param('token')){
      usr = await sails.helpers.authenticateRefreshToken(req.param('token'));
      if(!usr){ return res.status(403).send(); }
      await RefreshToken.destroy({uid: usr.id});
      return res.ok();
    }

    // Logout user with valid access token
    if(req.headers['authorization'] && req.headers['authorization'].split(' ')[1]){
      usr = await sails.helpers.authenticateJwt(req.headers);
      if(!usr){ return res.status(403).send(); }
      await RefreshToken.destroy({uid: usr.id});
      return res.ok();
    }

    return res.status(401).send();
  },

  refreshUserToken: async function(req, res){
    if(req.param('token') === null){ return res.status(401).send(); }
    var user = await sails.helpers.authenticateRefreshToken(req.param('token'));
    if(!user){ return res.status(403).send();}

    delete user['iat']; // Remove autogenerated attribute "initiated at"
    delete user['exp']; // Remove autogenerated attribute "expires at"

    const acessToken = jwt.sign(user, sails.config.jwts.ACCESS_TOKEN_SECRET, { expiresIn: sails.config.jwts.EXPIRATION_TIME });
    return res.json({accessToken: acessToken});
  },

};
